#version 450
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(binding = 0, std430) buffer SortBuffer { uint data[]; };

// Enhanced hash for better distribution
uint hash(uint x) {
    x = (x ^ 61) ^ (x >> 16);
    x *= 9;
    x = x ^ (x >> 4);
    x *= 0x27d4eb2d;
    x = x ^ (x >> 15);
    return x;
}

// Non-linear Kumaraswamy transform
float biased_kumaraswamy(float u, float viewport_ratio) {
    float base = 1.0 - sqrt(1.0 - u); // Original K(a=1,b=2)
    return base * exp(-4.0 * base / viewport_ratio); // Exponential decay
}

void main() {
    const uint max_patch = 10;
    const uint n = data.length();
    const float viewport_focus = 0.01; // Focus on first 1% of array
    
    // Hierarchical processing segments
    uint segment_size = uint(n * viewport_focus);
    uint segment_start = gl_WorkGroupID.x * segment_size;
    uint segment_end = min(segment_start + segment_size, n);
    
    if (segment_start >= n) return;

    // Thread-specific randomization
    uint seed = hash(gl_GlobalInvocationID.x + uint(1e7 * gl_NumWorkGroups.x));
    float u = float(seed & 0xFFFF) / 0xFFFF;
    
    // Apply non-linear probability distribution
    float k = biased_kumaraswamy(u, viewport_focus);
    uint local_start = uint(k * (segment_end - segment_start - max_patch));
    uint global_start = segment_start + local_start;
    
    // Position-based processing probability
    float depth_decay = exp(-8.0 * float(global_start)/float(n));
    if (float(hash(seed+123) & 0xFFFF)/0xFFFF > depth_decay) return;

    // Generate patch and sort
    uint patch_size = (hash(seed) % 9) + 2;
    uint patch_end = min(global_start + patch_size, n);
    
    if (patch_end - global_start < 2) return;

    // LSB radix pass with XOR swap
    for (uint i = global_start; i < patch_end - 1; i++) {
        uint a = data[i];
        uint b = data[i+1];
        uint lsb_mask = 0x1;
        
        if ((a & lsb_mask) > (b & lsb_mask)) {
            a ^= b;
            b ^= a;
            a ^= b;
            
            data[i] = a;
            data[i+1] = b;
        }
    }
}